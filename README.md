# <p align=center>Holbertonschool Higher Level Programming Project</p>
<img src="https://www.actuia.com/wp-content/uploads/2022/01/logopython.png" width="100%">

## Description
>Python is a high-level, interpreted, general-purpose programming language. It was first created in 1989 by Guido van Rossum. It is known for its clear and concise syntax, ease of use and large developer community. It is used in many fields such as data science, machine learning, robotics, web development, game development, etc. It is also used for developing scripts to automate common tasks and for creating small to medium-sized programs. Python supports multiple programming paradigms such as object-oriented programming, procedural programming and functional programming. It is also compatible with many operating systems including Windows, MacOS and Linux.

-------------------------------

## Projects

### [Python - Hello, World](https://github.com/MathieuMorel62/holbertonschool-higher_level_programming/tree/main/0x00-python-hello_world)
#### `General`

At the end of this project, you are expected to be able to [explain to anyone](https://intranet.hbtn.io/rltoken/gwuqSZXS7ElRbiObQzDcTg), **without the help of Google:**

<details>
<summary>Why Python programming is awesome</summary>
<br>

>Python programming is considered awesome due to its simplicity, readability, and versatility. It has a vast range of applications in areas such as web development, scientific computing, machine learning, and more.
</details>
<details>
<summary>Who created Python</summary>
<br>

>Python was created by Guido van Rossum, a Dutch programmer. It was first released in 1991.
</details>
<details>
<summary>Who is Guido van Rossum</summary>
<br>

>Guido van Rossum is a Dutch programmer who is best known as the creator of the Python programming language. He created Python in the late 1980s and released it in 1991.
</details>
<details>
<summary>Where does the name "Python" come from</summary>
<br>

>The name "Python" was inspired by the Monty Python's Flying Circus comedy series. Guido van Rossum is a fan of Monty Python, and he chose the name as a reference to the humor and absurdity in the series.
</details>
<details>
<summary>What is the Zen of Python</summary>
<br>

>The Zen of Python is a collection of 19 aphorisms that serve as guiding principles for writing computer programs in the Python language. It was written by Tim Peters and can be displayed in the Python interpreter by running `import this`.
</details>
<details>
<summary>How to use the Python interpreter</summary>
<br>

>The Python interpreter can be used in a number of ways, including in an interactive shell, as a command-line script interpreter, and as a component in larger software systems.
</details>
<details>
<summary>How to print text and variables using "print"</summary>
<br>

>To print text and variables using print in Python, you can use the `print()` function. You can pass one or more expressions as arguments to the function, and it will print the result to the console.
</details>
<details>
<summary>How to use strings</summary>
<br>

>Strings in Python are sequences of characters, and they are represented using quotes (either single or double). You can use operators such as `+` and `*` to concatenate and repeat strings, respectively.
</details>
<details>
<summary>What are indexing and slicing in Python</summary>
<br>

>Indexing and slicing in Python are techniques for accessing specific characters or substrings within a string. Indexing starts at 0, and a slice is specified using the start and end indices separated by a colon.
</details>
<details>
<summary>What is the official Python coding style and how to check your code with "pycodestyle"</summary>
<br>

>The official coding style for Python is called PEP 8 (Python Enhancement Proposal 8), and it provides guidelines for writing clear, readable, and consistent code. You can use the `pycodestyle` tool to check your code against the PEP 8 style guide.
</details>

-------------------------------

### [Python - if/else, Loops, Functions](https://github.com/MathieuMorel62/holbertonschool-higher_level_programming/tree/main/0x01-python-if_else_loops_functions)
#### `General`

At the end of this project, you are expected to be able to [explain to anyone](https://intranet.hbtn.io/rltoken/gwuqSZXS7ElRbiObQzDcTg), **without the help of Google:**

<details>
<summary>Why indentation is so important in Python</summary>
<br>

>Indentation is important in Python because it is used to define blocks of code. In Python, unlike in many other programming languages, whitespace (indentation) is used to indicate the scope and structure of the code, rather than brackets or keywords.
</details>
<details>
<summary>How to use the if, if ... else statements</summary>
<br>

>The `if` statement is used in Python to execute code only if a certain condition is met. The `if...else` statement is used to execute different code blocks depending on whether the condition is met or not.
</details>
<details>
<summary>How to use comments</summary>
<br>

>In Python, you can add comments to your code by using the `#` symbol. Anything after the `#` symbol on a line is treated as a comment and ignored by the interpreter.
</details>
<details>
<summary>How to affect values to variables</summary>
<br>

>Variables in Python are assigned values using the equal sign (=). For example assigns the value 10 to the variable x.

```python
x = 10
```
</details>
<details>
<summary>How to use the "while" and "for" loops</summary>
<br>

>The `while` loop is used in Python to repeat a block of code as long as a condition is met. The `for` loop is used to iterate over a sequence, such as a list or a range of numbers, and execute a block of code for each element in the sequence.
</details>
<details>
<summary>How is Python’s for different from "C"?</summary>
<br>

>Python's `for` loop is different from C's in that it can be used to iterate over any iterable object, not just arrays. In Python, the `for` loop automatically iterates over the items in a sequence, making it a more convenient and readable way to loop over data compared to C's `for` loop.
</details>
<details>
<summary>How to use the "break" and "continues" statements</summary>
<br>

>The `break` statement is used to exit a loop early, while the `continue` statement is used to skip the current iteration of the loop and move on to the next one.
</details>
<details>
<summary>How to use "else" clauses on loops</summary>
<br>

>The `else` clause on a loop can be used to execute code after the loop has completed, but only if the loop completed normally (i.e. not with a `break` statement).
</details>
<details>
<summary>What does the "pass" statement do, and when to use it</summary>
<br>

>The `pass` statement is a placeholder statement in Python and does nothing. It is used when a statement is required syntactically, but no action is required.
</details>
<details>
<summary>How to use "range"</summary>
<br>

>The `range` function generates a sequence of numbers, starting from 0 by default, and increments by 1 (by default), and stops before a specified number. You can use the `range` function in combination with the `for` loop to execute a block of code a specified number of times.
</details>
<details>
<summary>What is a function and how do you use functions</summary>
<br>

>A function in Python is a named block of code that can be executed by calling its name and passing arguments, if necessary. Functions can be used to encapsulate code that performs a specific task, making your code more modular and easier to maintain.
</details>
<details>
<summary>What does return a function that does not use any "return" statement</summary>
<br>

>A function that does not use a `return` statement returns `None`.
</details>
<details>
<summary>Scope of variables</summary>
<br>

>The scope of a variable refers to the region of the code in which it is defined and accessible. Variables defined inside a function have local scope, while variables defined outside of any function have global scope.
</details>
<details>
<summary>What’s a traceback</summary>
<br>

>A traceback is an error message that is generated when an exception occurs in your code. The traceback provides information about the error, including the location in the code where the error occurred and a description of the error.
</details>
<details>
<summary>What are the arithmetic operators and how to use them</summary>
<br>

>The arithmetic operators in Python include `+` (addition), `-` (subtraction), `*` (multiplication), `/` (division), `//` (floor division), `%` (modulus), `**` (exponentiation), and others. These operators can be used to perform mathematical operations on variables and values in Python.
</details>

------------------------

### [Python - Import & Modules](https://github.com/MathieuMorel62/holbertonschool-higher_level_programming/tree/main/0x02-python-import_modules)
#### `General`

At the end of this project, you are expected to be able to [explain to anyone](https://intranet.hbtn.io/rltoken/gwuqSZXS7ElRbiObQzDcTg), **without the help of Google:**

<details>
<summary>How to import functions from another file</summary>
<br>

>You can use the `import` statement to import functions from another file in Python. For example, if you have a file `my_functions.py` containing some functions and you want to import them into your main script, you can do it like this and You can then use the functions defined in the `my_functions.py` file in your main script by prefixing them with the name of the module, for example:

```python
import my_functions

my_functions.my_function()
```
</details>
<details>
<summary>How to use imported functions</summary>
<br>

>To use imported functions in Python, simply call the function by its name, preceded by the name of the module it was imported from. For example, if you imported a function `my_function` from a module `my_module`, you would call it using `my_module.my_function()`.
</details>
<details>
<summary>How to create a module</summary>
<br>

>A module in Python is simply a Python file with a `.py` extension that contains some functions or variables. To create a module, simply create a new file with the desired name and write your functions or variables in that file. You can then import that file into other scripts to make use of its contents.
</details>
<details>
<summary>How to use the built-in function dir()</summary>
<br>

>The `dir()` function is a built-in function in Python that returns a list of all the attributes and methods of a given object. For example, you can use `dir()` to find out all the attributes and methods of a module:

```python
import my_module
print(dir(my_module))
```

</details>
<details>
<summary>How to prevent code in your script from being executed when imported</summary>
<br>

>When a Python script is imported as a module into another script, any code at the top-level of that script will be executed. To prevent this, you can use the following code at the top-level of your script:

```python
if __name__ == "__main__":
    # code to be executed only when the script is run, not imported
```
</details>
<details>
<summary>How to use command line arguments with your Python programs</summary>
<br>

>You can use the sys.argv list to access command line arguments in your Python program. For example:

```python
import sys

print("Number of arguments: ", len(sys.argv))
print("Argument List: ", str(sys.argv))
```
</details>

---------------------------------

### [Python - Data Structures: Lists, Tuples](https://github.com/MathieuMorel62/holbertonschool-higher_level_programming/tree/main/0x03-python-data_structures)
#### `General`

At the end of this project, you are expected to be able to [explain to anyone](https://intranet.hbtn.io/rltoken/gwuqSZXS7ElRbiObQzDcTg), **without the help of Google:**

<details>
<summary>What are lists and how to use them</summary>
<br>

>Lists are a data structure in Python that are used to store an ordered collection of items, which can be of different data types such as integers, floating point numbers, strings, and other objects. Lists are defined using square brackets `[ ]` and items are separated by commas.

```python
fruits = ["apple", "banana", "cherry"]
```
</details>
<details>
<summary>What are the differences and similarities between strings and lists</summary>
<br>

>Strings and lists are similar in that they are both sequences of items. However, strings are immutable (cannot be changed), while lists are mutable (can be changed). This means that you can modify the items in a list, but you cannot modify the characters in a string.
</details>
<details>
<summary>What are the most common methods of lists and how to use them</summary>
<br>

>Some of the most commonly used methods in lists are:

- `append()`: Adds an item to the end of the list.

```python
fruits = ["apple", "banana"]
fruits.append("cherry")
print(fruits)
```

- `insert()`: Adds an item at a specified index.

```python
fruits = ["apple", "banana"]
fruits.insert(1, "cherry")
print(fruits)
```

- `extend()`: Adds multiple items to the end of the list.

```python
fruits = ["apple", "banana"]
fruits.extend(["cherry", "date"])
print(fruits)
```

- `remove()`: Removes the first item with the specified value.

```python
fruits = ["apple", "banana", "cherry"]
fruits.remove("banana")
print(fruits)
```

- `pop()`: Removes the item at the specified index (if no index is specified, it removes and returns the last item).

```python
fruits = ["apple", "banana", "cherry"]
fruits.pop(1)
print(fruits)
```
</details>
<details>
<summary>How to use lists as stacks and queues</summary>
<br>

>Lists can be used as stacks (last-in, first-out) by using the `append()` and `pop()` methods, and as queues (first-in, first-out) by using the `append()` and `pop(0)` methods.
</details>
<details>
<summary>What are list comprehensions and how to use them</summary>
<br>

>List comprehensions are a concise way to create lists in Python. They provide a compact and readable way to generate lists based on existing lists. In the below example, a new list squared is created, containing the squares of the numbers from 1 to 10.

```python
squared = [x**2 for x in range(1, 11)]
print(squared) 

# Output:
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
```
</details>
<details>
<summary>What are tuples and how to use them</summary>
<br>

>Tuples are similar to lists in Python, but they are immutable, meaning their values cannot be changed once created. Tuples are defined using parentheses `( )` and items are separated by commas.

```python
point = (2, 3)
print(point[0])
print(point[1])

# Output: 
2
3
```
</details>
<details>
<summary>When to use tuples versus lists</summary>
<br>

>Tuples are generally faster than lists for accessing items and are often used for short sequences of items that are not meant to be modified. On the other hand, lists are more flexible and are often used for longer sequences of items that are meant to be modified.
</details>
<details>
<summary>What is a sequence</summary>
<br>

>A sequence in Python is any collection of items, ordered by their position in the sequence. Both lists and tuples are examples of sequences.
</details>
<details>
<summary>What is tuple packing</summary>
<br>

>Tuple packing is a process of grouping values together into a single tuple. In Python, you can create a tuple by placing values separated by commas inside parentheses.

```python
point = 2, 3
print(point) 

# Output:
(2, 3)
```
</details>
<details>
<summary>What is sequence unpacking</summary>
<br>

>Sequence unpacking is the opposite of tuple packing. It is a process of extracting values from a sequence and assigning them to variables.

```python
point = (2, 3)
x, y = point
print(x)
print(y)

# Output: 
2
3
```
</details>
<details>
<summary>What is the 'del' statement and how to use it</summary>
<br>

>The `del` statement is used to delete objects in Python, such as variables, lists, and parts of lists. In the below example, the `del` statement is used to delete the item at index 1 (`"banana"`) from the list `fruits`.

```python
fruits = ["apple", "banana", "cherry"]
del fruits[1]
print(fruits) 

# Output:
["apple", "cherry"]
```
</details>

---------------------------------

### [Python - More Data Structures: Set, Dictionary](https://github.com/MathieuMorel62/holbertonschool-higher_level_programming/tree/main/0x04-python-more_data_structures)
#### `General`

At the end of this project, you are expected to be able to [explain to anyone](https://intranet.hbtn.io/rltoken/gwuqSZXS7ElRbiObQzDcTg), **without the help of Google:**

<details>
<summary>What are sets and how to use them</summary>
<br>

>Sets are collection data types in Python that are unordered and unchangeable. To use sets, you can create a set by enclosing a comma-separated list of elements in curly braces `{ }` or use the `set()` function.

```python
fruits = {"apple", "banana", "cherry"}
print("banana" in fruits) 

# Output:
True
```
</details>
<details>
<summary>What are the most common methods of set and how to use them</summary>
<br>

>The most common methods of sets include `union()`: Returns a set that contains all elements from both sets, `intersection()`: Returns a set that contains only elements that are common to both sets, `difference()`: Returns a set that contains elements that are in the first set but not in the second set, `add()`: Adds an element to a set, `remove()`: Removes an element from a set.

```python
fruits = {"apple", "banana", "cherry"}
fruits.add("orange")
fruits.remove("banana")
print(fruits) 

# Output:
{'apple', 'cherry', 'orange'}
```
</details>
<details>
<summary>When to use sets versus lists</summary>
<br>

>Use sets when you need to store multiple items in a collection and do not care about the order and duplicates are not allowed. Use lists when order matters and duplicates are allowed.
</details>
<details>
<summary>How to iterate into a set</summary>
<br>

>To iterate into a set, you can use a for loop.

```python
fruits = {"apple", "banana", "cherry"}
for fruit in fruits:
    print(fruit)

# output: 
apple
banana
cherry
```
</details>
<details>
<summary>What are dictionaries and how to use them</summary>
<br>

>Dictionaries are unordered collections of key-value pairs in Python. They are defined using curly braces `{ }` or the `dict()` constructor.

```python
person = {'name': 'John', 'age': 32, 'city': 'New York'}
print(person['name']) 

# Output:
'John'
```
</details>
<details>
<summary>When to use dictionaries versus lists or sets</summary>
<br>

>Use dictionaries when you need to associate values with keys, for example to store the properties of an object. Use lists or sets when you need to store items but don't care about associating them with keys.
</details>
<details>
<summary>What is a key in a dictionary</summary>
<br>

>A key in a dictionary is a unique identifier that is used to access the value associated with it.
</details>
<details>
<summary>How to iterate over a dictionary</summary>
<br>

>You can iterate over a dictionary using the `items()` method, which returns a view of the dictionary's key-value pairs.

```python
person = {'name': 'John', 'age': 32, 'city': 'New York'}
for key, value in person.items():
    print(key + ": " + str(value))

# output:
name: John
age: 32
city: New York
```
</details>
<details>
<summary>What is a lambda function</summary>
<br>

>Lambda functions are anonymous functions in Python, meaning they are functions without a name. They are defined using the lambda keyword.

```python
squared = lambda x: x**2
```
</details>
<details>
<summary>What are the map, reduce and filter functions</summary>
<br>

>The functions are built-in Python functions that are used to manipulate lists.

- `map()`: The `map()` function applies a function to each item in an iterable and returns a new iterable.

```python
numbers = [1, 2, 3, 4, 5]
squared_numbers = list(map(lambda x: x**2, numbers))
print(squared_numbers) 

# Output: 
[1, 4, 9, 16, 25]
```

- `reduce()`: The `reduce()` function applies a function to the items in an iterable in a cumulative way, reducing the iterable to a single value.

```python
from functools import reduce
numbers = [1, 2, 3, 4, 5]
product = reduce(lambda x, y: x * y, numbers)
print(product) 

# Output: 
120
```

- `filter()`: The `filter()` function filters elements from an iterable based on a given condition and returns a new iterable.

```python
numbers = [1, 2, 3, 4, 5]
even_numbers = list(filter(lambda x: x % 2 == 0, numbers))
print(even_numbers) 

# Output: 
[2, 4]
```
</details>

-----------------------------------

### [Python - Exceptions](https://github.com/MathieuMorel62/holbertonschool-higher_level_programming/tree/main/0x05-python-exceptions)
#### `General`

At the end of this project, you are expected to be able to [explain to anyone](https://intranet.hbtn.io/rltoken/gwuqSZXS7ElRbiObQzDcTg), **without the help of Google:**

<details>
<summary>What’s the difference between errors and exceptions</summary>
<br>

>The difference between errors and exceptions is that errors indicate a problem with the code itself, while exceptions are unexpected events that occur during the execution of a program and can be handled.
</details>
<details>
<summary>What are exceptions and how to use them</summary>
<br>

>Exceptions are errors that occur at runtime, and they interrupt the normal flow of execution. In Python, exceptions are handled using a `try` and `except` block.

```python
try:
   # code that may raise an exception
except ExceptionType as e:
   # code to handle the exception
```
</details>
<details>
<summary>When do we need to use exceptions</summary>
<br>

>We need to use exceptions when we want to handle unexpected events in our program, such as a user inputting an invalid value or a network connection failure.
</details>
<details>
<summary>How to correctly handle an exception</summary>
<br>

>To correctly handle an exception, you should catch it in a `try` block and provide a corresponding `except` block that will handle the exception. It is important to only catch exceptions that you know how to handle and to provide appropriate error messages to the user.

```python
try:
   # code that may raise an exception
except ExceptionType as e:
   # code to handle the exception
   print("An error has occurred:", e)
```
</details>
<details>
<summary>What’s the purpose of catching exceptions</summary>
<br>

>The purpose of catching exceptions is to provide a way to handle unexpected events and prevent the program from crashing. By catching an exception, we can take appropriate action, such as informing the user of the error or attempting to recover from the error.
</details>
<details>
<summary>How to raise a builtin exception</summary>
<br>

>You can raise a built-in exception using the `raise` keyword. For example, to raise a `ValueError` exception, you can use the following code:

```python
raise ValueError("Invalid value")
```
</details>
<details>
<summary>When do we need to implement a clean-up action after an exception</summary>
<br>

>Sometimes you need to perform a clean-up action after an exception has been raised. This can be achieved by using a `finally` block. The code in the `finally` block will be executed regardless of whether an exception was raised or not.

```python
try:
   # code that may raise an exception
except ExceptionType as e:
   # code to handle the exception
finally:
   # code to perform the clean-up action
```
</details>

-----------------------------------

### [Python - Classes And Objects](https://github.com/MathieuMorel62/holbertonschool-higher_level_programming/tree/main/0x06-python-classes)
#### `General`

At the end of this project, you are expected to be able to [explain to anyone](https://intranet.hbtn.io/rltoken/gwuqSZXS7ElRbiObQzDcTg), **without the help of Google:**

<details>
<summary>What is OOP</summary>
<br>

>OOP stands for Object-Oriented Programming, a programming paradigm based on the concept of `objects`, which can contain data and code that manipulates the data.
</details>
<details>
<summary>“first-class everything”</summary>
<br>

>In programming, the term "first-class" refers to an entity that can be treated as a value in the same way as a primitive data type like an integer or string. In the context of OOP, "first-class everything" means that objects, classes, and functions are all treated as first-class entities.
</details>
<details>
<summary>What is a class</summary>
<br>

>In Python, a class is a blueprint for creating objects (a particular data structure), providing initial values for state (member variables or attributes), and implementations of behavior (member functions or methods).
</details>
<details>
<summary>What is an object and an instance</summary>
<br>

>An object is an instance of a class and is created by calling the class as if it were a function. An instance is a specific occurrence of an object.
</details>
<details>
<summary>What is the difference between a class and an object or instance</summary>
<br>

>A class is a blueprint for creating objects, while an object is a specific instance of a class. A class defines the attributes and methods of an object, but it is not a concrete entity. An object, on the other hand, is a concrete entity that has a specific set of attributes and methods.
</details>
<details>
<summary>What is an attribute</summary>
<br>

>An attribute is a piece of data that is associated with an object. It can be thought of as a property or a characteristic of an object. In OOP, attributes are typically stored as member variables within a class.
</details>
<details>
<summary>What are and how to use public, protected and private attributes</summary>
<br>

>`Public attributes` can be accessed from anywhere. The `Protected attributes` can be accessed only within the class or by a subclass. They are denoted by a single underscore (`_`) before the attribute name. The `Private attributes` are intended for internal use and can only be accessed within the class. They are denoted by two underscores (`__`) before the attribute name.
</details>
<details>
<summary>What is self</summary>
<br>

>The `self` parameter in a method is a reference to the instance of the object that the method is called on. It is used to access the attributes and methods of the class.
</details>
<details>
<summary>What is a method</summary>
<br>

>A method is a function that is associated with an object or a class. It is used to define the behavior of an object or a class.
</details>
<details>
<summary>What is the special __init__ method and how to use it</summary>
<br>

>The `__init__` method is a special method that is automatically called when an object is created from a class. It is used to initialize the attributes of an object.

```python
class MyClass:
    def __init__(self, attr1, attr2):
        self.attr1 = attr1
        self.attr2 = attr2
```
</details>
<details>
<summary>What is Data Abstraction, Data Encapsulation, and Information Hiding</summary>
<br>

>`Data Abstraction` refers to the ability of an object to hide its internal details from the outside world and only reveal the necessary information. `Data Encapsulation` refers to the wrapping of data and functions into a single unit. `Information Hiding` refers to the practice of keeping the implementation details of a class hidden from the user.
</details>
<details>
<summary>What is a property</summary>
<br>

>A `property` in Python is a special kind of attribute that provides a way to access and manipulate an object's attributes in a more convenient way.
</details>
<details>
<summary>What is the difference between an attribute and a property in Python</summary>
<br>

>An attribute in Python is a named property of a class that is assigned a value. It's a value that describes the state of an object. On the other hand, a property is a special kind of attribute in Python that is defined using property methods such as `getter`, `setter`, and `deleter`. Properties are used to define the access control and behavior of an attribute.
</details>
<details>
<summary>What is the Pythonic way to write getters and setters in Python</summary>
<br>

>The Pythonic way to write getters and setters in Python is to use the `property` built-in function. This allows you to define the getter, setter, and deleter methods for an attribute in a concise and readable way. For example:

```python
class Rectangle:
    def __init__(self, width, height):
        self._width = width
        self._height = height

    @property
    def width(self):
        return self._width

    @width.setter
    def width(self, value):
        if value <= 0:
            raise ValueError("Width must be positive")
        self._width = value

    @property
    def height(self):
        return self._height

    @height.setter
    def height(self, value):
        if value <= 0:
            raise ValueError("Height must be positive")
        self._height = value
```
</details>
<details>
<summary>How to dynamically create arbitrary new attributes for existing instances of a class</summary>
<br>

>To dynamically create arbitrary new attributes for existing instances of a class, you can use the `setattr` function. This function takes an object and a string as arguments, and assigns the given value to the named attribute of the object. For example:

```python
class Person:
    pass

person = Person()
setattr(person, "name", "John Doe")
print(person.name) 
# outputs :
"John Doe"
```
</details>
<details>
<summary>How to bind attributes to object and classes</summary>
<br>

>You can bind attributes to objects and classes using the assignment operator (=). For instance, you can assign a value to a new attribute on an object by simply assigning it to an instance attribute. For example:

```python
class Person:
    pass

person = Person()
person.name = "John Doe"
```
</details>
<details>
<summary>What is the __dict__ of a class and/or instance of a class and what does it contain</summary>
<br>

>The `__dict__` of a class or instance of a class is a dictionary that contains the namespace of the class or instance. It contains the names and values of all the attributes defined in the class or instance.
</details>
<details>
<summary>How does Python find the attributes of an object or class</summary>
<br>

>Python finds the attributes of an object or class by searching the class hierarchy for a match. It first checks the `__dict__` of the object or class, and if it doesn't find the attribute there, it checks the parent class. This continues until Python reaches the base class (usually `object`) or until the attribute is found.
</details>
<details>
<summary>How to use the getattr function</summary>
<br>

>The `getattr` function is used to retrieve the value of an attribute from an object. It takes an object and a string as arguments, and returns the value of the named attribute. If the attribute does not exist, an AttributeError is raised. To avoid raising an error, you can provide a default value as a third argument to `getattr`. For example:

```python
class Person:
    def __init__(self, name):
        self.name = name
        self.age = 30

person = Person("John Doe")
print(getattr(person, "name", "Unknown")) # outputs "John Doe"
print(getattr(person, "age", "Unknown")) # outputs 30
print(getattr(person, "address", "Unknown")) # outputs "Unknown"
```
</details>

----------------------------

### [Python - Test-driven development](https://github.com/MathieuMorel62/holbertonschool-higher_level_programming/tree/main/0x07-python-test_driven_development)
#### `General`

At the end of this project, you are expected to be able to [explain to anyone](https://intranet.hbtn.io/rltoken/gwuqSZXS7ElRbiObQzDcTg), **without the help of Google:**

<details>
<summary>What’s an interactive test</summary>
<br>

>An interactive test is a test that can be executed by the user and requires input or interaction to evaluate the output.
</details>
<details>
<summary>Why tests are important</summary>
<br>

>Tests are important because they help ensure that the code is functioning as expected, especially when making changes to the code. Tests help catch bugs early in the development process, making it easier and faster to fix them.
</details>
<details>
<summary>How to write Docstrings to create tests</summary>
<br>

>Docstrings can be used to create tests by including examples of how to use the code and what the expected output should be. For example:

```python
def add(a, b):
    """
    This function adds two numbers and returns the result.

    Example:
    >>> add(2, 3)
    5
    >>> add(4, -1)
    3
    """
    return a + b
```
</details>
<details>
<summary>How to write documentation for each module and function</summary>
<br>

>Documentation for each module and function should describe what the code does, how to use it, and what the inputs and outputs are. This documentation can be written in the form of docstrings, comments, or in a separate documentation file. For example:

```python
def add(a, b):
    """
    This function adds two numbers and returns the result.

    :param a: The first number to add.
    :type a: int
    :param b: The second number to add.
    :type b: int
    :return: The sum of the two numbers.
    :rtype: int

    Example:
    >>> add(2, 3)
    5
    """
    return a + b
```
</details>
<details>
<summary>What are the basic option flags to create tests</summary>
<br>

>The basic option flags to create tests using the `unittest` module in Python include `-v` for verbose output, `-q` for quiet output, `-b` for running the tests without capturing output, and `-f` for running only the tests that failed in the last run.
</details>
<details>
<summary>How to find edge cases</summary>
<br>

>To find edge cases, you can think about the inputs to your code that are at the boundaries of the expected input range, or inputs that are unexpected or unconventional. You can also use automated testing tools or techniques, such as fuzz testing, to generate a large number of random test cases and check for edge cases. Additionally, manual testing and inspection can also be used to find edge cases.
</details>

--------------------------

### [Python - More Classes and Objects](https://github.com/MathieuMorel62/holbertonschool-higher_level_programming/tree/main/0x08-python-more_classes)
#### `General`

At the end of this project, you are expected to be able to [explain to anyone](https://intranet.hbtn.io/rltoken/gwuqSZXS7ElRbiObQzDcTg), **without the help of Google:**

<details>
<summary>What is OOP</summary>
<br>

>Object-Oriented Programming (OOP) is a programming paradigm that is based on the concept of "objects". Objects are instances of classes that have properties and methods. OOP is used to structure and organize code, making it easier to understand and maintain.
</details>
<details>
<summary>“first-class everything”</summary>
<br>

>"First-class everything" refers to the idea in programming that all entities, including functions and objects, should be treated as first-class citizens, meaning they can be assigned to variables, passed as arguments, and returned as results.
</details>
<details>
<summary>What is a class</summary>
<br>

>A class is a blueprint or template for creating objects. It defines the attributes and behaviors that the objects created from the class will have.
</details>
<details>
<summary>What is an object and an instance</summary>
<br>

>An object is an instance of a class, created from the class blueprint. An instance is a specific occurrence of an object created from a class.
</details>
<details>
<summary>What is the difference between a class and an object or instance</summary>
<br>

>The difference between a class and an object or instance is that a class is a blueprint or template for creating objects, while an object is an actual instance of the class, with its own specific values for attributes.
</details>
<details>
<summary>What is an attribute</summary>
<br>

>An attribute is a variable that is associated with an object or class, and represents a property or characteristic of that object or class.
</details>
<details>
<summary>What are and how to use public, protected and private attributes</summary>
<br>

>Public, protected, and private attributes are different levels of visibility and accessibility for class attributes. Public attributes can be accessed from anywhere, protected attributes can be accessed only within the class and its subclasses, and private attributes can only be accessed within the class.
</details>
<details>
<summary>What is self</summary>
<br>

>`Self` is a special keyword in Python that refers to the instance of the object that a method is being called on. It is used to access attributes and other methods of the object.
</details>
<details>
<summary>What is a method</summary>
<br>

>A method is a function that is associated with an object or class, and operates on or with the attributes of that object or class.
</details>
<details>
<summary>What is the special __init__ method and how to use it</summary>
<br>

>The `__init__` method is a special method in Python that is automatically called when an object is created from a class. The `__init__` method is used to initialize the properties of an object.
</details>
<details>
<summary>What is Data Abstraction, Data Encapsulation, and Information Hiding</summary>
<br>

>Data Abstraction is the process of hiding the implementation details of a class and exposing only the necessary information to the outside world. Data Encapsulation is the technique of wrapping data and methods into a single unit, or object, to provide a secure way of accessing the data. Information Hiding is the practice of hiding the internal details of an object and exposing a public interface to the outside world.
</details>
<details>
<summary>What is a property</summary>
<br>

>A property is a special kind of attribute in Python, which provides a convenient way to access, control, and manipulate the attributes of an object, such as getting or setting values, or adding constraints or restrictions.
</details>
<details>
<summary>What is the difference between an attribute and a property in Python</summary>
<br>

>The difference between an attribute and a property in Python is that an attribute is a variable associated with an object or class, while a property is a method used to access or modify the attribute.
</details>
<details>
<summary>What is the Pythonic way to write getters and setters in Python</summary>
<br>

>The Pythonic way to write getters and setters is to use the `@property` and `@attribute.setter` decorators.
</details>
<details>
<summary>What are the special __str__ and __repr__ methods and how to use them</summary>
<br>

>The `__str__` and `__repr__` methods are special methods in Python that are used to define a string representation of an object. The `__str__` method is used to return a human-readable string representation of an object, while the `__repr__` method is used to return a string that can be used to recreate the object.
</details>
<details>
<summary>What is the difference between __str__ and __repr__</summary>
<br>

>The `__str__` is a special method in Python that is used to define a human-readable string representation of an object. It is intended to be used as a string representation that could be used by end-users to understand what the object represents. The `__repr__` is also a special method in Python that defines a string representation of an object, but it is intended to be a complete and unambiguous representation of the object. The goal is to provide a string representation that could be used to recreate an equivalent object.
</details>
<details>
<summary>What is a class attribute</summary>
<br>

>A class attribute is a variable associated with the class, rather than a specific instance of the class.
</details>
<details>
<summary>What is the difference between a object attribute and a class attribute</summary>
<br>

>The difference between an object attribute and a class attribute is that an object attribute is associated with a specific instance of the class, while a class attribute is associated with the class as a whole.
</details>
<details>
<summary>What is a class method</summary>
<br>

>A class method is a method that is bound to the class and not to an instance of the class. It can be called on the class itself, rather than on an instance of the class. Class methods are defined using the `@classmethod` decorator.
</details>
<details>
<summary>What is a static method</summary>
<br>

>A static method is a method that is defined within a class but has no access to class-specific information such as the class name, class attributes, etc. It is defined using the `@staticmethod` decorator.
</details>
<details>
<summary>How to dynamically create arbitrary new attributes for existing instances of a class</summary>
<br>

>New attributes can be dynamically created for instances of a class by simply assigning a value to a new variable using the dot notation. For example:

```python
class MyClass:
    def __init__(self):
        self.attribute = None

my_instance = MyClass()
my_instance.new_attribute = 42
```
</details>
<details>
<summary>How to bind attributes to object and classes</summary>
<br>

>`Object attributes` can be bound to instances of a class by assigning values to them within an instance method. `Class attributes` can be bound to the class itself by assigning values to them outside of any method in the class.
</details>
<details>
<summary>What is and what does contain __dict__ of a class and of an instance of a class</summary>
<br>

>The `__dict__` attribute of a class is a dictionary that contains all the attributes of the class, including its methods and variables. The `__dict__` attribute of an instance of a class is a dictionary that contains all the attributes of the instance, including its variables, but not its methods.
</details>
<details>
<summary>How does Python find the attributes of an object or class</summary>
<br>

>Python finds the attributes of an object or class by looking in the object's or class's `dict`, and then in its parent class's `dict` if the attribute is not found.
</details>
<details>
<summary>How to use the getattr function</summary>
<br>

>The `getattr` function is used to access an attribute of an object or class. It takes two arguments: the object or class and the name of the attribute to access. If the attribute does not exist, `getattr` can return a default value that is provided as a third argument. For example:

```python
class MyClass:
    def __init__(self):
        self.attribute = 42

my_instance = MyClass()
value = getattr(my_instance, "attribute", "Attribute not found")
print(value)  # Output: 42

value = getattr(my_instance, "non_existing_attribute", "Attribute not found")
print(value)  # Output: Attribute not found
```
</details>

---------------------------
### [Python - Everything Is Object](https://github.com/MathieuMorel62/holbertonschool-higher_level_programming/tree/main/0x09-python-everything_is_object)
#### `General`

At the end of this project, you are expected to be able to [explain to anyone](https://intranet.hbtn.io/rltoken/gwuqSZXS7ElRbiObQzDcTg), **without the help of Google:**

<details>
<summary>What is an object</summary>
<br>

>An object in programming is a specific instance of a data structure defined by a class. It contains data and behavior (methods) that operate on that data. Objects are the fundamental building blocks of object-oriented programming (OOP).
</details>
<details>
<summary>What is the difference between a class and an object or instance</summary>
<br>

>A class is a blueprint for creating objects. It defines the properties and behaviors that objects of that class will have. An object, also known as an instance, is a specific realization of a class. For example, if you have a class for creating a dog, then each dog you create would be an instance of that class.
</details>
<details>
<summary>What is the difference between immutable object and mutable object</summary>
<br>

>An `immutable object` is an object whose state cannot be changed after it is created. For example, a string in Python is an immutable object because once you create a string, you cannot change the characters in it. On the other hand, a `mutable object` is an object whose state can be changed after it is created. For example, a list in Python is a mutable object because you can add, remove, or change elements in a list after it is created.
</details>
<details>
<summary>What is a reference</summary>
<br>

>A reference is a value that refers to an object in memory. It is a way to access the object and its data. In Python, variables are references to objects.
</details>
<details>
<summary>What is an assignment</summary>
<br>

>In Python, an assignment is the operation of creating a reference to an object by giving a name to the object. The assignment operator is the equal sign (=), and is used to assign a value to a variable. For example:

```python
x = 42
```
</details>
<details>
<summary>What is an alias</summary>
<br>

>An alias is a reference to an object that has more than one name. When you assign an object to another variable, you are creating an alias for the object. For example:

```python
x = 42
y = x
```
</details>
<details>
<summary>How to know if two variables are identical</summary>
<br>

>To know if two variables are identical, you can use the `is` operator. The `is` operator returns `True` if the two variables refer to the same object, and `False` otherwise. For example:

```python
x = 42
y = 42
print(x is y)
```
</details>
<details>
<summary>How to know if two variables are linked to the same object</summary>
<br>

>To know if two variables are linked to the same object, you can use the `is` operator. The `is` operator returns `True` if the two variables refer to the same object, and `False` otherwise. For example:

```python
x = [1, 2, 3]
y = x
print(x is y)
```
</details>
<details>
<summary>How to display the variable identifier (which is the memory address in the CPython implementation)</summary>
<br>

>To display the variable identifier, which is the memory address in the CPython implementation, you can use the `id` built-in function. The `id` function returns a unique identifier for the object, which can be used to determine if two objects are the same. For example:

```python
x = 42
print(id(x))
```
</details>
<details>
<summary>What is mutable and immutable</summary>
<br>

>Mutable and immutable are terms used to describe the state of an object. An immutable object is one whose state cannot be changed after it is created, while a mutable object is one whose state can be changed after it is created.
</details>
<details>
<summary>What are the built-in mutable types</summary>
<br>

>The built-in mutable types in Python include lists, dictionaries, sets, and bytearrays.
</details>
<details>
<summary>What are the built-in immutable types</summary>
<br>

>The built-in immutable types in Python include numbers (integers, floating-point numbers, and complex numbers), strings, tuples, and frozensets.
</details>
<details>
<summary>How does Python pass variables to functions</summary>
<br>

>In Python, variables are passed to functions by reference. This means that when a function receives a variable, it receives a reference to the object referred to by that variable. If the function modifies the object, the changes will be visible outside the function as well. If you want to pass an object to a function such that the function cannot modify it, you should pass an immutable object.
</details>

--------------------------
### [Python - Inheritance](https://github.com/MathieuMorel62/holbertonschool-higher_level_programming/tree/main/0x0A-python-inheritance)
#### `General`

At the end of this project, you are expected to be able to [explain to anyone](https://intranet.hbtn.io/rltoken/gwuqSZXS7ElRbiObQzDcTg), **without the help of Google:**

<details>
<summary>What is a superclass, baseclass or parentclass</summary>
<br>

>A superclass, baseclass, or parentclass is a higher-level class from which other classes inherit attributes and methods. In other words, a subclass inherits from its parent class.
</details>
<details>
<summary>What is a subclass</summary>
<br>

>A subclass is a lower-level class that inherits attributes and methods from a parent class (also known as a superclass or baseclass). The subclass can add or override attributes and methods of the parent class.
</details>
<details>
<summary>How to list all attributes and methods of a class or instance</summary>
<br>

>To list all attributes and methods of a class or instance, you can use the built-in `dir()` function in Python.

```python
class MyClass:
    def method(self):
        pass

obj = MyClass()
print(dir(MyClass))
print(dir(obj))
```
</details>
<details>
<summary>When can an instance have new attributes</summary>
<br>

>An instance of a class can have new attributes that are not part of the class definition. You can add new attributes to an instance at any time, by simply assigning a value to a new variable with the same name as the instance.

```python
class MyClass:
    pass

obj = MyClass()
obj.new_attribute = 42
```
</details>
<details>
<summary>How to inherit class from another</summary>
<br>

>To inherit a class from another class, you use the `class` statement with a `(SuperClass)` argument, where `SuperClass` is the name of the class to inherit from. Here's an example:

```python
class SuperClass:
    def method(self):
        print("SuperClass method")

class SubClass(SuperClass):
    pass

obj = SubClass()
obj.method()
```
</details>
<details>
<summary>How to define a class with multiple base classes</summary>
<br>

>To define a class with multiple base classes, you use the `class` statement with a tuple of base classes as its argument. Here's an example:

```python
class Base1:
    pass

class Base2:
    pass

class SubClass(Base1, Base2):
    pass
```

</details>
<details>
<summary>What is the default class every class inherit from</summary>
<br>

>Every class in Python implicitly inherits from the `object` class. The `object` class is the root of the class hierarchy in Python, and all classes inherit from it by default.
</details>
<details>
<summary>How to override a method or attribute inherited from the base class</summary>
<br>

>To override a method or attribute inherited from the base class, you simply define a new method or attribute with the same name in the subclass. The new method or attribute will then be used instead of the one inherited from the base class. Here's an example:

```python
class SuperClass:
    def method(self):
        print("SuperClass method")

class SubClass(SuperClass):
    def method(self):
        print("SubClass method")

obj = SubClass()
obj.method()
```
</details>
<details>
<summary>Which attributes or methods are available by heritage to subclasses</summary>
<br>

>All attributes and methods that are defined in a parent class are available for use by subclasses. Subclasses can access these attributes and methods using the dot operator, for example `Subclass.attribute` or `Subclass.method().`
</details>
<details>
<summary>What is the purpose of inheritance</summary>
<br>

>The purpose of inheritance is to allow a subclass to inherit attributes and methods from a parent class, thus avoiding the need to rewrite the same code in multiple classes. Inheritance allows you to create a hierarchy of classes, where lower-level classes inherit attributes and methods from higher-level classes, making it easier to reuse code and create more specialized classes.
</details>
<details>
<summary>What are, when and how to use isinstance, issubclass, type and super built-in functions</summary>
<br>

>The built-in functions `isinstance()`, `issubclass()`, `type()`, and `super()` are used for testing the type
</details>

------------------------------
### [Python - Input/Output](https://github.com/MathieuMorel62/holbertonschool-higher_level_programming/tree/main/0x0B-python-input_output)
#### `General`

At the end of this project, you are expected to be able to [explain to anyone](https://intranet.hbtn.io/rltoken/gwuqSZXS7ElRbiObQzDcTg), **without the help of Google:**

<details>
<summary>How to open a file</summary>
<br>

>To open a file in Python, you can use the built-in `open()` function. This function takes the file name as an argument and returns a file object that you can use to read or write the file. The second argument to the `open()` function specifies the mode in which to open the file. In this case, `"r"` means "read".Here's an example:

```python
file = open("example.txt", "r") # open the file for reading
```
</details>
<details>
<summary>How to write text in a file</summary>
<br>

>To write to a file, you can use the `write()` method of the file object. Here's an example:

```python
file = open("example.txt", "w") # open the file for writing
file.write("This is some text.") # write text to the file
file.close() # close the file
```
</details>
<details>
<summary>How to read the full content of a file</summary>
<br>

>To read the entire contents of a file, you can use the `read()` method of the file object. Here's an example:

```python
file = open("example.txt", "r") # open the file for reading
content = file.read() # read the entire contents of the file
print(content) # print the contents
file.close() # close the file
```
</details>
<details>
<summary>How to read a file line by line</summary>
<br>

>To read a file line by line, you can use a `for` loop and the `readline()` method of the file object. Here's an example:

```python
file = open("example.txt", "r") # open the file for reading
for line in file:
    print(line)
file.close() # close the file
```
</details>
<details>
<summary>How to move the cursor in a file</summary>
<br>

>The position of the cursor in a file can be changed using the `seek()` method of the file object. This method takes an offset (in bytes) as an argument, and moves the cursor to the specified position. Here's an example:

```python
file = open("example.txt", "r") # open the file for reading
print(file.tell()) # print the current position of the cursor
file.seek(10) # move the cursor to the 10th byte
print(file.tell()) # print the current position of the cursor
file.close() # close the file
```
</details>
<details>
<summary>How to make sure a file is closed after using it</summary>
<br>

>It's important to close a file after you're done using it to release the resources it was using and to prevent corruption of the file's contents. You can close a file using the `close()` method of the file object. Here's an example:

```python
file = open("example.txt", "r") # open the file for reading
# do some file operations
file.close() # close the file
```
</details>
<details>
<summary>What is and how to use the with statement</summary>
<br>

>The `with` statement is used in Python to ensure that a resource is automatically released when it's no longer needed. When used with a file, it automatically closes the file when the block of code inside the `with` statement is finished. Here's an example:

```python
with open("example.txt", "r") as file:
    content = file.read()
    print(content)
```
</details>
<details>
<summary>What is JSON</summary>
<br>

>JSON (JavaScript Object Notation) is a lightweight data-interchange format that is easy for humans to read and write, and easy for machines to parse and generate. It is based on a subset of the JavaScript programming language, and is commonly used to transmit data between a server and a web application. JSON data is represented as key-value pairs, similar to a dictionary in Python.
</details>
<details>
<summary>What is serialization</summary>
<br>

>Serialization is the process of converting a data structure into a format that can be stored or transmitted across a network. The goal of serialization is to convert the state of an object into a form that can be reconstructed later in the same or another computer environment.
</details>
<details>
<summary>What is deserialization</summary>
<br>

>Deserialization is the reverse process of serialization, where data is converted from a string representation back into its original data structure. The goal of deserialization is to reconstruct the original object from the serialized form.
</details>
<details>
<summary>How to convert a Python data structure to a JSON string</summary>
<br>

>To convert a Python data structure to a JSON string, you can use the `json` module in Python. The `json.dumps()` function converts a Python object into a JSON-formatted string. Here's an example:

```python
import json

data = {"name": "John", "age": 30, "city": "New York"}
json_string = json.dumps(data, indent=4)
print(json_string)
```
</details>
<details>
<summary>How to convert a JSON string to a Python data structure</summary>
<br>

>To convert a JSON string to a Python data structure, you can use the `json` module in Python. The `json.loads()` function converts a JSON-formatted string into a Python object. Here's an example:

```python
import json

json_string = '{"name": "John", "age": 30, "city": "New York"}'
data = json.loads(json_string)
print(data)
```
</details>

------------------------------

### [Python - Almost a circle](https://github.com/MathieuMorel62/holbertonschool-higher_level_programming/tree/main/0x0C-python-almost_a_circle)
#### `General`

At the end of this project, you are expected to be able to [explain to anyone](https://intranet.hbtn.io/rltoken/gwuqSZXS7ElRbiObQzDcTg), **without the help of Google:**

<details>
<summary>What is Unit testing and how to implement it in a large project</summary>
<br>

>Unit testing is a software testing technique that involves writing test cases for individual units or components of a software application. The purpose of unit testing is to isolate and test each part of the code to ensure that it performs as expected. To implement unit testing in a large project, you should:
      
    - Write test cases for each function or module that you want to test.
    - Use a testing framework such as pytest or unittest to automate the testing process.
    - Integrate the testing process into your development workflow, such as by running the tests automatically every time you make changes to the code.
    - Run the tests regularly to ensure that your code is functioning as expected.
</details>
<details>
<summary>How to serialize and deserialize a Class</summary>
<br>

>Serialization is the process of converting a class or object into a format that can be stored or transmitted, while deserialization is the reverse process of converting the serialized data back into an object or class. In Python, you can serialize and deserialize a class using the pickle module. Here's an example:

```python
import pickle

class MyClass:
    def __init__(self, value):
        self.value = value

# Serialize
my_object = MyClass(42)
serialized_object = pickle.dumps(my_object)

# Deserialize
deserialized_object = pickle.loads(serialized_object)
print(deserialized_object.value) 

# Output: 42
```
</details>
<details>
<summary>How to write and read a JSON file</summary>
<br>

>JSON is a lightweight data interchange format that is widely used in web applications. In Python, you can write and read a JSON file using the json module. Here's an example:

```python
import json

# Write to file
data = {"name": "John", "age": 30}
with open("data.json", "w") as f:
    json.dump(data, f)

# Read from file
with open("data.json", "r") as f:
    data = json.load(f)
print(data) 
    
# Output: {'name': 'John', 'age': 30}
```
</details>
<details>
<summary>What is *args and how to use it</summary>
<br>

>`*args` is a special syntax in Python that allows a function to accept any number of positional arguments. The `*` before the variable name indicates that the arguments will be collected into a tuple. Here's an example:

```python
def my_function(*args):
    for arg in args:
        print(arg)

my_function(1, 2, 3) 
    
# Output: 1 2 3
```
</details>
<details>
<summary>What is **kwargs and how to use it</summary>
<br>

>**kwargs is another special syntax in Python that allows a function to accept any number of keyword arguments. The ** before the variable name indicates that the arguments will be collected into a dictionary. Here's an example:
    
```python
def my_function(**kwargs):
    for key, value in kwargs.items():
        print(key, value)

my_function(name="John", age=30) 
    
# Output: name John age 30
```
</details>
<details>
<summary>How to handle named arguments in a function</summary>
<br>

>In Python, you can handle named arguments in a function using the `**kwargs` syntax. In this example, the `**kwargs` parameter allows the function to accept any additional named arguments that were not defined in the function signature. The function then checks whether the city argument was passed and prints a message accordingly.
    
```python
def my_function(name, age, **kwargs):
    if "city" in kwargs:
        print(f"{name} lives in {kwargs['city']}.")
    else:
        print(f"{name} does not have a city listed.")

my_function("John", 30, city="New York")
my_function("Jane", 25)
    
# Output: John lives in New York.
# Output: Jane does not have a city listed.
```
</details>

--------------------------------

## Author

- Mathieu Morel
